# Surface code 讲稿



## Surface code 的构造

Surface code 的构造如上图所示，其中白色圆点表示 data qubit，黑色圆点表示 measure qubit，measure qubit 又分为两种，用 $X$ 和 $Z$ 表示，它们与周围的 4 个 data qubit 连接（在边界处的是 3 个）

这些测量对应的可观测量就是该稳定子码对应的稳定子群 $S$ 的生成元，但是符号尚未确定。一般我们不会事先确定这些生成元的符号，而是经过多轮测量，等到其测量结果稳定后，根据测量结果决定。

## 单比特错误

此处仅考虑 Pauli 错误。

若在某个 data qubit 上出现了 $X$ 错误，则与其相邻的两个 $Z$-measure qubit 的测量结果会发生翻转，十分容易据此定位错误。

如果是某个 measure qubit 上出现 $X$ 错误，注意到这样的错误最多影响一轮测量的一个测量结果，很容易与上面的错误区分。

对于 $Z$ 错误，也可以如此分析。

因此，Surface code 可以有效抵抗单比特错误。

（补充）对于多比特错误，在测量结果上表现为多个测量位置的翻转，暂且假定测量过程无误，我们可以通过搜索找出匹配这种错误症状的 Pauli 错误的组合，然后假定它是weight 最小的那一个。这是因为一般来说错误发生的概率都比较小。

## 定义 $X_L$ 和 $Z_L$ 算子

可以验证，沿着上图蓝（红）线，在经过的 data qubit 上作用 $X$（$Z$），定义了 $X_L$（$Z_L$）算子。

这样定义的逻辑算子在乘上一个 $S$ 中的元素的意义下唯一，例如上图沿着紫线定义的 $X_L'$ 算子，就可以看作是 $X_L$ 乘上一个 $S$ 中的元素，忽略符号。

## 基于缺陷的 Surface code

我们可以关闭两个 $X$（$Z$）-measure qubit 来为 Surface code 带来额外的自由度，并在该自由度下定义逻辑量子比特，这种方法称为缺陷，按图索骥就能定义该编码下的逻辑算子。

这么做的优点有：算子的定义不依赖平面边界，原来需要有两个 $X$-边界和两个 $Z$-边界；减少了逻辑算子实际作用在 physical qubit 上的算子数量；方便进行测量和初始化；可以通过 topological braid transformation 来定义 $CNOT$ 操作。

缺点是： 纠错码的距离 $d$ 减小了，仅为 $4$，$4$ 个 data qubit 上的 $Z$ 错误可能就无法通过测量分辨，然而这一点是受限于缺陷的大小，如果我们关闭更多的 measure qubit，制造更大的缺陷，就可以提高 $d$。

## 移动缺陷

（a）到（b），先关闭一个 measure qubit，进行一轮测量，注意这里也需要测量由于断开连接而被孤立的那个 data qubit，新的逻辑算子有这样的变化： 

（b）到（c），打开上面的一个 measure qubit，再进行一轮测量，则逻辑算子有这样的变化：

新得到的逻辑算子可能在符号上与原来的逻辑算子不一样，这取决于测量的结果，记原来的逻辑量子态在新编码下的表示为 $|\psi '\rangle$，对 $X_6$ 和 （b）中 $Z_L^e$ 的测量结果分别为 $P_X$ 和 $P_Z$，则变换的结果为：

这样的移动自然可以推广到多比特上，只需要像单比特一样关闭路径上的 measure qubit，进行一轮测量，然后再打开即可。

## $CNOT$ 的构造

一个平面上有着 $X$ 和 $Z$ 缺陷表示的两个 logical qubit。
可以利用上面介绍的移动缺陷的方法，分成两步移动，让一个 $Z$-缺陷绕着一个 $X$-缺陷移动一圈，这种操作等效于 $CNOT$。这可以由该操作在逻辑算子上的作用来验证，我们发现这个效果等同于一个 $CNOT$ gate 的共轭作用。

